var U=Object.defineProperty;var ae=Object.getOwnPropertyDescriptor;var se=Object.getOwnPropertyNames;var re=Object.prototype.hasOwnProperty;var ie=(e,n)=>{for(var o in n)U(e,o,{get:n[o],enumerable:!0})},ne=(e,n,o,c)=>{if(n&&typeof n=="object"||typeof n=="function")for(let i of se(n))!re.call(e,i)&&i!==o&&U(e,i,{get:()=>n[i],enumerable:!(c=ae(n,i))||c.enumerable});return e};var oe=e=>ne(U({},"__esModule",{value:!0}),e);var fe={};ie(fe,{AutoActions:()=>ge,getObjectCardDefinitions:()=>q,getObjectCards:()=>pe});module.exports=oe(fe);var j=require("protobase");var k=require("protobase");var D=require("protobase");var de=(0,k.getLogger)(),ce=e=>{let n,o;try{o=JSON.parse(e.cookies.session)}catch{o=null}var c="";let i=e.headers?.authorization;if(i&&i.startsWith("Bearer ")?c=i.slice(7):(e.query.token||o&&o.token)&&(c=e.query.token?e.query.token:o.token,Array.isArray(c)&&(c=c[0])),c)try{n=(0,k.createSession)((0,D.verifyToken)(c))}catch(p){de.error({error:p},"Error reading token"),n=(0,k.createSession)()}else n=(0,k.createSession)();return{session:n,token:c}},_=e=>async(n,o,c)=>{try{let i=ce(n);await e(n,o,{...i.session,token:i.token},c)}catch(i){if(i instanceof k.ZodError){let p=i.flatten();o.status(400).send(p)}else i.toString()=="E_PERM"?o.status(403).send({error:i.toString()}):i.toString()=="E_AUTH"?o.status(401).send({error:i.toString()}):i.toString()=="File already exists"?o.status(409).send({error:i.toString()}):o.status(500).send({error:i.toString()})}};var g=require("protobase");var W=e=>{switch(e){case"number":return"number";case"boolean":return"boolean";case"array":case"object":case"record":return"json";case"string":case"date":case"relation":case"union":default:return"string"}},ue=(e,n)=>{let o={},c={};for(let[i,p]of Object.entries(e)){let C=p.modifiers?.some(f=>f.name==="id"),v=p.modifiers?.some(f=>f.name==="generate");if(p.modifiers?.some(f=>f.name==="hidden"))continue;let w=p.modifiers?.find(f=>f.name==="label")?.params?.[0]?.replace(/['"]/g,"")||i,y=p.modifiers?.find(f=>f.name==="hint")?.params?.[0]?.replace(/['"]/g,"")||"",u=W(p.type),l=y||`${w} (${p.type})${C?" - this will be used as the id":""}`;o[i]=l,c[i]={visible:!0,defaultValue:p.type==="boolean"?!1:p.type==="number"?0:"",type:u}}return{params:o,configParams:c}},le=e=>`const action = userParams.action;
delete userParams["action"];

if (action == "create") {
    return execute_action("/api/v1/actions/${e}/create", userParams);
} else if (action == "update") {
    return execute_action("/api/v1/actions/${e}/update", userParams);
} else if (action == "read") {
    return execute_action("/api/v1/actions/${e}/read", userParams);
} else if (action == "delete") {
  return execute_action("/api/v1/actions/${e}/delete", userParams);
} else if (action == "exists") {
  return execute_action("/api/v1/actions/${e}/exists", userParams);
} else if (action == "select") {
  if (!userParams.selectedItem) {
    return
  }

  return {
    selected: userParams.selectedItem.data, 
    items: await execute_action("/api/v1/actions/${e}/list", {})
  };
} else {
  return {
    selected: null, 
    items: await execute_action("/api/v1/actions/${e}/list", {})
  };
}`,q=({modelName:e,modelType:n,pluralName:o,object:c,html:i={},keys:p})=>{let C=o??e,v=(u,l)=>i[u]?i[u]:l,P={},a={},w={id:`id of the ${e} to update`,field:`field to update in the ${e}`,value:"new value for the field"},m={id:{visible:!0,defaultValue:"",type:"string"},field:{visible:!0,defaultValue:"",type:"string"},value:{visible:!0,defaultValue:"",type:"any"}};if(p&&Object.keys(p).length>0){let u=ue(p,e);P=u.params,a=u.configParams;let l=Object.keys(p).filter(f=>!p[f].modifiers?.some(b=>b.name==="hidden"));w={id:`id of the ${e} to update`,field:`field to update in the ${e}. Possible fields: ${l.join(", ")}`,value:"new value for the field"}}else if(n?.getObjectFieldsDefinition){let u=n.getObjectFieldsDefinition();P=Object.keys(u).filter(l=>u[l].autogenerate==!1).map(l=>({[l]:u[l].description+" ("+u[l].type+")"+(u[l].isId?" (this will be used as the id of the element)":"")})).reduce((l,f)=>({...l,...f}),{}),a=Object.keys(u).filter(l=>u[l].autogenerate==!1).reduce((l,f)=>(l[f]={visible:!0,defaultValue:u[f].type==="boolean"?!1:u[f].type==="number"?0:"",type:W(u[f].type)},l),{}),w={id:`id of the ${e} to update`,field:`field to update in the ${e}. Possible fields: ${Object.keys(u).join(", ")}`,value:"new value for the field"}}return[{group:"storages",tag:e,name:"exists",id:"storage_"+e+"_exists",templateName:"Check if a "+e+" exists in the storage",defaults:{html:v("exists"),width:2,height:8,icon:"file-check",displayResponse:!0,name:`exists ${e}`,type:"action",description:`Check if ${e} exists given an id. Returns true if it exists, false otherwise.`,params:{id:"id to look for"},rulesCode:`return execute_action("/api/v1/actions/${e}/exists", userParams)`}},{group:"storages",tag:e,name:"table",id:"storage_"+e+"_last_table",templateName:"Last "+e+" table",defaults:{width:3,height:8,name:"Table",icon:"table-properties",description:"Displays a table with the last "+C,type:"value",html:v("last_table",`
//data contains: data.value, data.icon and data.color
return card({
    content: cardTable(data.value), padding: '3px'
});
`),rulesCode:`return states.storages?.${e}.lastEntries`}},{group:"storages",tag:e,name:"read",id:"storage_"+e+"_read",templateName:"Read "+e+" from the storage",defaults:{html:v("read"),width:2,height:8,icon:"file-search",displayResponse:!0,name:`read ${e}`,type:"action",description:`Reads${e} given an id. Returns the content of the object if it exists, false otherwise.`,params:{id:`id of the ${e} to read`},rulesCode:`return execute_action("/api/v1/actions/${e}/read", userParams)`}},{group:"storages",tag:e,name:"create",id:"storage_"+e+"_create",templateName:"Create "+e+" in the storage",defaults:{html:v("create"),width:2,height:Math.max(8,6+Object.keys(P).length*2),icon:"file-plus",displayResponse:!0,name:`create ${e}`,type:"action",description:`Creates a ${e} given its content. Returns the created ${e}.`,params:P,configParams:a,rulesCode:`return execute_action("/api/v1/actions/${e}/create", userParams)`}},{group:"storages",tag:e,name:"delete",id:"storage_"+e+"_delete",templateName:"Delete "+e+" from the storage",defaults:{width:2,height:8,icon:"trash",displayResponse:!0,name:`delete ${e}`,type:"action",html:v("delete"),description:`Deletes ${e} by id. Returns true if it was deleted, false otherwise.`,params:{id:"id of the "+e+" to delete"},rulesCode:`return execute_action("/api/v1/actions/${e}/delete", userParams)`}},{group:"storages",tag:e,name:"update",id:"storage_"+e+"_update",templateName:"Updates "+e+" in the storage",defaults:{html:v("update"),width:2,height:12,icon:"file-pen-line",displayResponse:!0,name:`update ${e}`,type:"action",description:`Updates a ${e} by id, changing field with a given value. Returns the updated ${e} if it was updated, false otherwise.`,params:w,configParams:m,rulesCode:`return execute_action("/api/v1/actions/${e}/update", userParams)`}},{group:"storages",tag:e,name:"lastCreated",id:"storage_"+e+"_lastCreated",templateName:"Last created "+e,defaults:{width:2,height:8,html:v("lastCreated"),type:"value",icon:"rss",name:`lastCreated ${e}`,description:`Last Created ${e}`,rulesCode:`return states.storages?.${e}.lastCreated;`}},{group:"storages",tag:e,name:"lastUpdated",id:"storage_"+e+"_lastUpdated",templateName:"Last updated "+e,defaults:{html:v("lastUpdated"),type:"value",icon:"rss",name:`lastUpdated ${e}`,description:`Last updated ${e}`,rulesCode:`return states.storages?.${e}.lastUpdated;`}},{group:"storages",tag:e,name:"totalItems",id:"storage_"+e+"_totalitems",templateName:"Total "+C,defaults:{html:v("totalItems"),type:"value",icon:"boxes",name:`Total ${C}`,description:`Total ${C}`,rulesCode:`return states.storages?.${e}.total;`}},{group:"storages",tag:e,name:"list",id:"storage_"+e+"_manager",templateName:e+" storage manager",emitEvent:!0,defaults:{width:4,height:10,icon:"search",displayResponse:!0,method:"post",name:`${e} storage manager`,html:`//@card/react\r
\r
function Widget(card) {\r
  return (\r
      <Tinted>\r
        <ProtoThemeProvider forcedTheme={window.TamaguiTheme}>\r
         <StorageView name="`+(c??e)+`" onItemsChange={() => execute_action(card.name, {})} onSelectItem={(item) => execute_action(card.name, {action: "select", selectedItem: JSON.stringify(item)})}/>\r
        </ProtoThemeProvider>\r
      </Tinted>\r
  );\r
}\r
`,type:"action",description:`Returns a list of ${e} objects. You can filter the results by passing itemsPerPage, page, search, orderBy and orderDirection parameters.`,params:{itemsPerPage:"number of items per page (optional)",page:"page number to retrieve (optional)",search:"search term to filter the results (optional)",orderBy:"field to order the results by (optional)",orderDirection:"direction to order the results by (asc or desc) (optional)",action:"action to perform in the storage: list, read, create, update, delete, exists",id:"id (required for actions: read, create, update, delete, exists)",selectedItem:"selected item on user click"},configParams:{selectedItem:{defaultValue:"",type:"json"}},presets:{create:{description:"creates/adds item to the storage",configParams:{action:{defaultValue:"create"}}},update:{description:"updates field of item of the storage",configParams:{action:{defaultValue:"update"}}},read:{description:"reads item of the storage",configParams:{action:{defaultValue:"read"}}},delete:{description:"deletes item of the storage",configParams:{action:{defaultValue:"delete"}}},list:{description:"list items of the storage",configParams:{action:{defaultValue:"list"}}},select:{configParams:{action:{defaultValue:"action"},selectedItem:{defaultValue:"",type:"json"}}},exists:{description:"checks if exists item on the storage",configParams:{action:{defaultValue:"exists"}}}},rulesCode:le(e)}},{group:"storages",tag:e,name:"search",id:"storage_"+e+"_search",templateName:e+" storage search",emitEvent:!0,defaults:{width:2,height:8,icon:"search",displayResponse:!0,method:"post",name:`Search ${e} in storage`,html:`//@card/react

function Widget(card) {
  const value = card.value;

  const content = <YStack f={1} ai="center" jc="center" width="100%">
      {card.icon && card.displayIcon !== false && (
          <Icon name={card.icon} size={48} color={card.color}/>
      )}
      {card.displayResponse !== false && (
          <CardValue mode={card.markdownDisplay ? 'markdown' : card.htmlDisplay ? 'html' : 'normal'} value={value ?? "N/A"} />
      )}
  </YStack>

  return (
      <Tinted>
        <ProtoThemeProvider forcedTheme={window.TamaguiTheme}>
          <ActionCard data={card}>
            {card.displayButton !== false ? <ParamsForm data={card}>{content}</ParamsForm> : card.displayResponse !== false && content}
          </ActionCard>
        </ProtoThemeProvider>
      </Tinted>
  );
}
`,type:"action",description:`Search ${e} in the storage and returns a list of ${e} objects. You can use use querys in natural language for searching`,params:{search:"search term",ai_mode:"enables natural language search mode"},configParams:{search:{visible:!0,defaultValue:"",type:"string"},ai_mode:{visible:!0,defaultValue:"true",type:"boolean"}},rulesCode:`return execute_action("/api/v1/actions/${e}/list", {\r
    ...params,\r
    mode: params.ai_mode ? 'ai' : 'normal'\r
})`}}]},pe=e=>{let n=q(e),o=(0,g.getServiceToken)();return n.map(c=>({...c,token:o}))},ge=({modelName:e,modelType:n,apiUrl:o=void 0,prefix:c="/api/v1/",object:i=void 0,notificationsName:p=void 0,pluralName:C=void 0,html:v={}})=>async(P,a)=>{let w=C??e,m=o??`${c}${e}`,y=`${c}actions/${e}`,u=p??e,l=async()=>{try{let t=await j.API.get(`${m}?token=${(0,g.getServiceToken)()}`);t.isLoaded&&t.data&&t.data.total&&(a.state.set({group:"storages",tag:e,name:"total",value:t.data.total}),a.state.set({group:"storages",tag:e,name:"lastEntries",value:t.data.items}))}catch(t){console.error("Error loading total for "+e,t)}return 0};setTimeout(()=>l(),1e3);let f=q({modelName:e,modelType:n,pluralName:w,object:i,html:v}),b=t=>f.find(s=>s.name===t);P.get(y+"/exists",_(async(t,s,d)=>{let h=t.query.id;try{if((await j.API.get(`${m}/${h}?token=${d.token}`)).isLoaded){s.json(!0);return}s.json(!1);return}catch{s.status(500).json(!1);return}})),await a.actions.add({group:"storages",name:"exists",url:y+"/exists",tag:e,description:`Check if ${e} exists given an id. Returns true if it exists, false otherwise.`,params:{id:"id to look for"},token:(0,g.getServiceToken)()});let A=b("exists");A&&await a.cards.add({...A,token:(0,g.getServiceToken)()});let V=b("table");V&&await a.cards.add({...V,token:(0,g.getServiceToken)()});let Z=t=>t!==null&&typeof t=="object"&&!Array.isArray(t),Q=t=>typeof t=="string"&&t.length>1&&(t[0]==="{"&&t.at(-1)==="}"||t[0]==="["&&t.at(-1)==="]"),L=(t,s)=>{switch(s){case"number":return typeof t=="number"?t:Number(t);case"boolean":{let d;return typeof t=="boolean"?d=t:typeof t=="number"?d=t!==0:typeof t=="string"?d=t==="true"||t==="1"||t==="on"||t==="yes":d=!!t,d}case"record":{if(Z(t))return t;if(Q(t))try{return JSON.parse(t)}catch{}return t}case"string":default:return typeof t=="string"?t:String(t)}},E=(t,s)=>{let d=s.getObjectFieldsDefinition?.()??{};for(let r of Object.keys(t)){let h=d[r]?.type;h&&(t[r]=L(t[r],h))}return t},X=(t,s)=>{let d=s.getObjectFieldsDefinition?.()??{};if(typeof t.field=="string"&&"value"in t){let r=d[t.field]?.type;r&&(t.value=L(t.value,r))}return t};P.get(y+"/read",_(async(t,s,d)=>{let r=t.query;delete r._stackTrace;let h=r.id;try{let $=await j.API.get(`${m}/${h}?token=${d.token}`);if($.isLoaded){E($.data,n),s.json($.data);return}s.json(!1);return}catch{s.status(500).json(!1);return}})),await a.actions.add({group:"storages",name:"read",url:y+"/read",tag:e,description:`Read ${e} given an id. Returns an object with the data of the ${e} if it exists, false otherwise.`,params:{id:`id of the ${e} to read`},token:(0,g.getServiceToken)()});let F=b("read");F&&await a.cards.add({...F,token:(0,g.getServiceToken)()}),P.post(y+"/create",_(async(t,s,d)=>{let r=t.body;delete r._stackTrace,E(r,n);try{let h=await j.API.post(`${m}?token=${d.token}`,r);if(h.isLoaded){s.json(h.data);return}s.json(!1);return}catch{s.status(500).json(!1);return}}));let R=n.getObjectFieldsDefinition(),N=Object.keys(R).filter(t=>R[t].autogenerate==!1).map(t=>({[t]:R[t].description+" ("+R[t].type+")"+(R[t].isId?" (this will be used as the id of the element)":"")})).reduce((t,s)=>({...t,...s}),{});await a.actions.add({group:"storages",name:"create",url:y+"/create",tag:e,description:`Creates new ${e} given an object with the data. Returns the id of the new ${e}.`,params:N,token:(0,g.getServiceToken)(),method:"post"});let M=b("create");M&&await a.cards.add({...M,token:(0,g.getServiceToken)()}),a.events.onEvent(a.mqtt,a,async t=>{l(),a.state.set({group:"storages",tag:e,name:"lastDeleteddId",value:t?.payload?.id})},u+"/delete/#"),P.get(y+"/delete",_(async(t,s,d)=>{let h=t.query.id;try{if((await j.API.get(`${m}/${h}/delete?token=${d.token}`)).isLoaded){s.json(!0);return}s.json(!1);return}catch{s.status(500).json(!1);return}})),await a.actions.add({group:"storages",name:"delete",url:y+"/delete",tag:e,description:`Deletes ${e} given an id. Returns true if it was deleted, false otherwise.`,params:{id:"id of the "+e+" to delete"},token:(0,g.getServiceToken)()});let B=b("delete");B&&await a.cards.add({...B,token:(0,g.getServiceToken)()}),P.get(y+"/update",_(async(t,s,d)=>{let r=t.query;delete r._stackTrace,X(r,n);let h=r.id,$=r.field,I=r.value;try{let T=await j.API.get(`${m}/${h}?token=${r.token?r.token:d.token}`);if(T.isLoaded){let O=T.data;O[$]=I;let x=await j.API.post(`${m}/${h}?token=${r.token?r.token:d.token}`,O);if(x.isLoaded){s.json(x.data);return}}}catch{s.status(500).json(!1);return}}));let ee={id:`id of the ${e} to update`,field:`field to update in the ${e}. Possible fields: ${Object.keys(R).join(", ")}`,value:"new value for the field"};await a.actions.add({group:"storages",name:"update",url:y+"/update",tag:e,description:`Updates ${e} by id, changing field with a given value. Returns the updated ${e} if it was updated, false otherwise.`,params:ee,token:(0,g.getServiceToken)()});let H=b("update");H&&await a.cards.add({...H,token:(0,g.getServiceToken)()}),a.events.onEvent(a.mqtt,a,async t=>{l(),a.state.set({group:"storages",tag:e,name:"lastCreated",value:t?.payload?.data}),a.state.set({group:"storages",tag:e,name:"lastCreatedMetadata",value:t}),a.state.set({group:"storages",tag:e,name:"lastCreatedId",value:t?.payload?.id})},u+"/create/#");let z=b("lastCreated");z&&a.cards.add({...z,token:(0,g.getServiceToken)()}),a.events.onEvent(a.mqtt,a,async t=>{a.state.set({group:"storages",tag:e,name:"lastUpdated",value:t?.payload?.data}),a.state.set({group:"storages",tag:e,name:"lastUpdatedMetadata",value:t}),a.state.set({group:"storages",tag:e,name:"lastUpdatedId",value:t?.payload?.id})},u+"/update/#");let Y=b("lastUpdated");Y&&a.cards.add({...Y,token:(0,g.getServiceToken)()});let G=b("totalItems");G&&a.cards.add({...G,token:(0,g.getServiceToken)()}),P.get(y+"/list",_(async(t,s,d)=>{let r=t.query,h=r.itemsPerPage,$=r.page,I=r.search,T=r.orderBy,O=r.orderDirection,x=r.mode||"normal",te=`${m}?token=${d.token}&${h?`itemsPerPage=${h}`:""}${$?`&page=${$}`:""}${I?`&search=${I}`:""}${T?`&orderBy=${T}`:""}${O?`&orderDirection=${O}`:""}${x?`&mode=${x}`:""}`;try{let S=await j.API.get(te);if(S.isLoaded){s.json(S.data.items);return}s.json(!1);return}catch{s.status(500).json(!1);return}})),await a.actions.add({group:"storages",name:"list",url:y+"/list",tag:e,description:`Returns a list of ${e} objects. You can filter the results by passing itemsPerPage, page, search, orderBy and orderDirection parameters.`,params:{itemsPerPage:"number of items per page (optional)",page:"page number to retrieve (optional)",search:"search term to filter the results (optional)",orderBy:"field to order the results by (optional)",orderDirection:"direction to order the results by (asc or desc) (optional)"},token:(0,g.getServiceToken)()});let J=b("list");J&&await a.cards.add({...J,token:(0,g.getServiceToken)()});let K=b("search");K&&await a.cards.add({...K,token:(0,g.getServiceToken)()})};0&&(module.exports={AutoActions,getObjectCardDefinitions,getObjectCards});
